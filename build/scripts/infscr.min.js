(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./src/scripts/infscr.js":[function(require,module,exports){
(function (angular) {
var infscr = angular.module('infscr', []);

infscr.config(function ($httpProvider) {
	delete $httpProvider.defaults.headers.common['X-Requested-With'];
});


// scrollDiv defines the object to be used as a directive
function scrollDiv ($window) {
  'use strict';

  // this function loads on the defined element
  return function (scope, element, attrs) {
      // position starts at 0
      scope.position = 0;

      // wait for the LOADDONE event
      scope.$on('LOADDONE', function (event) {
        scope.position = Math.floor(((window.pageYOffset + $(window).height()) / $(document).height()) * 100);
        
        angular.element(window).bind('scroll', function () {          
          scope.position = Math.floor(((this.pageYOffset + $(window).height()) / $(document).height()) * 100);
          if (scope.position > 85) {
            scope.getMore();
          }
          scope.$apply();
        });

        if (scope.count >= 60) {
          angular.element(window).unbind('scroll');
        }
      });

    }
}

// assign scrollDiv to a directive
// in a minification safe manner
infscr.directive('scrollDiv', ['$window', scrollDiv]);






// The getStoryList function uses angularjs' $http
// object to make xhr's to get stories
function getStoryList ($http) {

  // the url to request stories from
  var url = 'http://golfweek.com/json/';

  return {
    // the get function should suffice for most normal uses
    // it accepts a context object to get info about the sections
    // ctx also needs a success function to return the data
    get: function (ctx) {
      // the category function is here for future use with sections and sub sections
      // currently it is not used
      var category = (ctx.section === undefined) ? '' : ctx.section;
      category += (ctx.sub === undefined || ctx.sub === 'all') ? '' : '/' + ctx.sub;
      category += (ctx.subsub === undefined) ? '' : '/' + ctx.subsub;
      category += (ctx.subsubsub === undefined) ? '' : '/' + ctx.subsubsub;
      
      // the count is at minimum 15 but must be in increments of 15 currently
      var count = (ctx.count === undefined) ? 15 : ctx.count;
      
      // make the request to golfweek 
      // ***MUST BE A POST OR ELLINGTON BLOCKS IT***
      $http.post(url + 'section/?Section=' + category + '&Num=' + count)
        .success(function (data) {  
          ctx.success(data);
        })
        .error(function (data, status) {
          console.log(data, status);
        });
    }
  }
}


// Assign getStoryList as an angular factory 
// in a manner safe for minification
infscr.factory('getStoryList', ['$http', getStoryList]);



// the getStoryContent function is intended to load the clicked
// story into the selected div
function getStoryContent ($http) {
  
  // the base url to request the storydata from
  var url = 'http://golfweek.com/';

  return {
    get: function (ctx) {      
      $http.post(url + ctx.slug + '?json')
        .success(function (data) {
          ctx.storySuccess(data);
        })
        .error(function (data, status) {
          console.log(data, status);
        });
    }
  }
}


// Assign getStoryList as an angular factory 
// in a manner safe for minification
infscr.factory('getStoryContent', ['$http', getStoryContent]);



// the infScrollController function is intended to be used 
// in the div where the stories should be added for infinite 
// scrolling
function infScrollController ($scope, $window, storyList, story) {
	$scope.count = 15;  // number of stories to get
	$scope.fetching = false; // are we fetching right now?
  $scope.stories = []; // starts out as an empty array

  $scope.$on('LOAD', function (e) { $scope.fetching = true; });
  $scope.$on('LOADDONE', function (e) { $scope.fetching = false; });

  // this is the success handler when data is received
  $scope.success = function (data) {
    angular.forEach(data.stories, function (val, key) {
      this[key] = val;
    }, $scope.stories);
    // console.log('%O', $scope.stories[0]);
    // let everything know we are done loading
    $scope.$emit('LOADDONE');
  }

  // get the stories the first time
  storyList.get($scope);

  // getMore should be used when the div is scrolled
	$scope.getMore = function () {
		// if page position is bigger than 88 
		// fetch more stories
		if (!$scope.fetching) {
      $scope.$emit('LOAD');
      $scope.count = ($scope.count === 60) ? 60 : $scope.count + 15;
			// let everything know we are loading
      storyList.get($scope);

		}
	}

  $scope.storySuccess = function (data) {
    // set the data here to the expanding div for the story
    // console.log('%o', $scope.stories);
    $scope.stories[$scope.storyId]['storyContent'] = data.story[0];
    console.log(data);
  }


  $scope.storyClick = function () {
    // console.log('%o',this.$index)
    $scope.slug = this.story.id;
    $scope.storyId = this.$index;
    story.get($scope);
  }


}


// Assign infScrollController as an angular controller 
// in a manner safe for minification
infscr.controller('infScrollCtrl', ['$scope', '$window', 'getStoryList', 'getStoryContent', infScrollController]);






(function () {

  var THECODE = [38,38,40,40,37,39,37,39,66,65];

  var testcode = [];
  var time;

  // k code stuff
  function checkKeys (e) {
    var button = (e.keyCode);

    if (THECODE.indexOf(button) > -1) {
      testcode[testcode.length] = e.keyCode;

      if (testcode.length === THECODE.length) {
        checkCode();
      } else {
        clearCode();
      }
    }
  }

  function checkCode () {
    for (var i = 0; i < THECODE.length; i++) {
      if (THECODE[i] !== testcode[i]) {
        testcode = [];
        break;
      }
    }
    if (testcode.length > 0) {
      console.log('duf time!');
    }
  }

  function clearCode () {
    if (time === undefined) {
      time = window.setTimeout(function() {
        testcode = [];
        window.clearTimeout(time);
      }, 10000);
    }
  }


  window.addEventListener('keydown', checkKeys);
})()


})(angular);
},{}]},{},["./src/scripts/infscr.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuL3NyYy9zY3JpcHRzL2luZnNjci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAoYW5ndWxhcikge1xudmFyIGluZnNjciA9IGFuZ3VsYXIubW9kdWxlKCdpbmZzY3InLCBbXSk7XG5cbmluZnNjci5jb25maWcoZnVuY3Rpb24gKCRodHRwUHJvdmlkZXIpIHtcblx0ZGVsZXRlICRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtUmVxdWVzdGVkLVdpdGgnXTtcbn0pO1xuXG5cbi8vIHNjcm9sbERpdiBkZWZpbmVzIHRoZSBvYmplY3QgdG8gYmUgdXNlZCBhcyBhIGRpcmVjdGl2ZVxuZnVuY3Rpb24gc2Nyb2xsRGl2ICgkd2luZG93KSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyB0aGlzIGZ1bmN0aW9uIGxvYWRzIG9uIHRoZSBkZWZpbmVkIGVsZW1lbnRcbiAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIC8vIHBvc2l0aW9uIHN0YXJ0cyBhdCAwXG4gICAgICBzY29wZS5wb3NpdGlvbiA9IDA7XG5cbiAgICAgIC8vIHdhaXQgZm9yIHRoZSBMT0FERE9ORSBldmVudFxuICAgICAgc2NvcGUuJG9uKCdMT0FERE9ORScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzY29wZS5wb3NpdGlvbiA9IE1hdGguZmxvb3IoKCh3aW5kb3cucGFnZVlPZmZzZXQgKyAkKHdpbmRvdykuaGVpZ2h0KCkpIC8gJChkb2N1bWVudCkuaGVpZ2h0KCkpICogMTAwKTtcbiAgICAgICAgXG4gICAgICAgIGFuZ3VsYXIuZWxlbWVudCh3aW5kb3cpLmJpbmQoJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHsgICAgICAgICAgXG4gICAgICAgICAgc2NvcGUucG9zaXRpb24gPSBNYXRoLmZsb29yKCgodGhpcy5wYWdlWU9mZnNldCArICQod2luZG93KS5oZWlnaHQoKSkgLyAkKGRvY3VtZW50KS5oZWlnaHQoKSkgKiAxMDApO1xuICAgICAgICAgIGlmIChzY29wZS5wb3NpdGlvbiA+IDg1KSB7XG4gICAgICAgICAgICBzY29wZS5nZXRNb3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2NvcGUuY291bnQgPj0gNjApIHtcbiAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQod2luZG93KS51bmJpbmQoJ3Njcm9sbCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH1cbn1cblxuLy8gYXNzaWduIHNjcm9sbERpdiB0byBhIGRpcmVjdGl2ZVxuLy8gaW4gYSBtaW5pZmljYXRpb24gc2FmZSBtYW5uZXJcbmluZnNjci5kaXJlY3RpdmUoJ3Njcm9sbERpdicsIFsnJHdpbmRvdycsIHNjcm9sbERpdl0pO1xuXG5cblxuXG5cblxuLy8gVGhlIGdldFN0b3J5TGlzdCBmdW5jdGlvbiB1c2VzIGFuZ3VsYXJqcycgJGh0dHBcbi8vIG9iamVjdCB0byBtYWtlIHhocidzIHRvIGdldCBzdG9yaWVzXG5mdW5jdGlvbiBnZXRTdG9yeUxpc3QgKCRodHRwKSB7XG5cbiAgLy8gdGhlIHVybCB0byByZXF1ZXN0IHN0b3JpZXMgZnJvbVxuICB2YXIgdXJsID0gJ2h0dHA6Ly9nb2xmd2Vlay5jb20vanNvbi8nO1xuXG4gIHJldHVybiB7XG4gICAgLy8gdGhlIGdldCBmdW5jdGlvbiBzaG91bGQgc3VmZmljZSBmb3IgbW9zdCBub3JtYWwgdXNlc1xuICAgIC8vIGl0IGFjY2VwdHMgYSBjb250ZXh0IG9iamVjdCB0byBnZXQgaW5mbyBhYm91dCB0aGUgc2VjdGlvbnNcbiAgICAvLyBjdHggYWxzbyBuZWVkcyBhIHN1Y2Nlc3MgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBkYXRhXG4gICAgZ2V0OiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAvLyB0aGUgY2F0ZWdvcnkgZnVuY3Rpb24gaXMgaGVyZSBmb3IgZnV0dXJlIHVzZSB3aXRoIHNlY3Rpb25zIGFuZCBzdWIgc2VjdGlvbnNcbiAgICAgIC8vIGN1cnJlbnRseSBpdCBpcyBub3QgdXNlZFxuICAgICAgdmFyIGNhdGVnb3J5ID0gKGN0eC5zZWN0aW9uID09PSB1bmRlZmluZWQpID8gJycgOiBjdHguc2VjdGlvbjtcbiAgICAgIGNhdGVnb3J5ICs9IChjdHguc3ViID09PSB1bmRlZmluZWQgfHwgY3R4LnN1YiA9PT0gJ2FsbCcpID8gJycgOiAnLycgKyBjdHguc3ViO1xuICAgICAgY2F0ZWdvcnkgKz0gKGN0eC5zdWJzdWIgPT09IHVuZGVmaW5lZCkgPyAnJyA6ICcvJyArIGN0eC5zdWJzdWI7XG4gICAgICBjYXRlZ29yeSArPSAoY3R4LnN1YnN1YnN1YiA9PT0gdW5kZWZpbmVkKSA/ICcnIDogJy8nICsgY3R4LnN1YnN1YnN1YjtcbiAgICAgIFxuICAgICAgLy8gdGhlIGNvdW50IGlzIGF0IG1pbmltdW0gMTUgYnV0IG11c3QgYmUgaW4gaW5jcmVtZW50cyBvZiAxNSBjdXJyZW50bHlcbiAgICAgIHZhciBjb3VudCA9IChjdHguY291bnQgPT09IHVuZGVmaW5lZCkgPyAxNSA6IGN0eC5jb3VudDtcbiAgICAgIFxuICAgICAgLy8gbWFrZSB0aGUgcmVxdWVzdCB0byBnb2xmd2VlayBcbiAgICAgIC8vICoqKk1VU1QgQkUgQSBQT1NUIE9SIEVMTElOR1RPTiBCTE9DS1MgSVQqKipcbiAgICAgICRodHRwLnBvc3QodXJsICsgJ3NlY3Rpb24vP1NlY3Rpb249JyArIGNhdGVnb3J5ICsgJyZOdW09JyArIGNvdW50KVxuICAgICAgICAuc3VjY2VzcyhmdW5jdGlvbiAoZGF0YSkgeyAgXG4gICAgICAgICAgY3R4LnN1Y2Nlc3MoZGF0YSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5lcnJvcihmdW5jdGlvbiAoZGF0YSwgc3RhdHVzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZGF0YSwgc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cblxuLy8gQXNzaWduIGdldFN0b3J5TGlzdCBhcyBhbiBhbmd1bGFyIGZhY3RvcnkgXG4vLyBpbiBhIG1hbm5lciBzYWZlIGZvciBtaW5pZmljYXRpb25cbmluZnNjci5mYWN0b3J5KCdnZXRTdG9yeUxpc3QnLCBbJyRodHRwJywgZ2V0U3RvcnlMaXN0XSk7XG5cblxuXG4vLyB0aGUgZ2V0U3RvcnlDb250ZW50IGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGxvYWQgdGhlIGNsaWNrZWRcbi8vIHN0b3J5IGludG8gdGhlIHNlbGVjdGVkIGRpdlxuZnVuY3Rpb24gZ2V0U3RvcnlDb250ZW50ICgkaHR0cCkge1xuICBcbiAgLy8gdGhlIGJhc2UgdXJsIHRvIHJlcXVlc3QgdGhlIHN0b3J5ZGF0YSBmcm9tXG4gIHZhciB1cmwgPSAnaHR0cDovL2dvbGZ3ZWVrLmNvbS8nO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoY3R4KSB7ICAgICAgXG4gICAgICAkaHR0cC5wb3N0KHVybCArIGN0eC5zbHVnICsgJz9qc29uJylcbiAgICAgICAgLnN1Y2Nlc3MoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBjdHguc3RvcnlTdWNjZXNzKGRhdGEpO1xuICAgICAgICB9KVxuICAgICAgICAuZXJyb3IoZnVuY3Rpb24gKGRhdGEsIHN0YXR1cykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEsIHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5cbi8vIEFzc2lnbiBnZXRTdG9yeUxpc3QgYXMgYW4gYW5ndWxhciBmYWN0b3J5IFxuLy8gaW4gYSBtYW5uZXIgc2FmZSBmb3IgbWluaWZpY2F0aW9uXG5pbmZzY3IuZmFjdG9yeSgnZ2V0U3RvcnlDb250ZW50JywgWyckaHR0cCcsIGdldFN0b3J5Q29udGVudF0pO1xuXG5cblxuLy8gdGhlIGluZlNjcm9sbENvbnRyb2xsZXIgZnVuY3Rpb24gaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBcbi8vIGluIHRoZSBkaXYgd2hlcmUgdGhlIHN0b3JpZXMgc2hvdWxkIGJlIGFkZGVkIGZvciBpbmZpbml0ZSBcbi8vIHNjcm9sbGluZ1xuZnVuY3Rpb24gaW5mU2Nyb2xsQ29udHJvbGxlciAoJHNjb3BlLCAkd2luZG93LCBzdG9yeUxpc3QsIHN0b3J5KSB7XG5cdCRzY29wZS5jb3VudCA9IDE1OyAgLy8gbnVtYmVyIG9mIHN0b3JpZXMgdG8gZ2V0XG5cdCRzY29wZS5mZXRjaGluZyA9IGZhbHNlOyAvLyBhcmUgd2UgZmV0Y2hpbmcgcmlnaHQgbm93P1xuICAkc2NvcGUuc3RvcmllcyA9IFtdOyAvLyBzdGFydHMgb3V0IGFzIGFuIGVtcHR5IGFycmF5XG5cbiAgJHNjb3BlLiRvbignTE9BRCcsIGZ1bmN0aW9uIChlKSB7ICRzY29wZS5mZXRjaGluZyA9IHRydWU7IH0pO1xuICAkc2NvcGUuJG9uKCdMT0FERE9ORScsIGZ1bmN0aW9uIChlKSB7ICRzY29wZS5mZXRjaGluZyA9IGZhbHNlOyB9KTtcblxuICAvLyB0aGlzIGlzIHRoZSBzdWNjZXNzIGhhbmRsZXIgd2hlbiBkYXRhIGlzIHJlY2VpdmVkXG4gICRzY29wZS5zdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBhbmd1bGFyLmZvckVhY2goZGF0YS5zdG9yaWVzLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgIHRoaXNba2V5XSA9IHZhbDtcbiAgICB9LCAkc2NvcGUuc3Rvcmllcyk7XG4gICAgLy8gY29uc29sZS5sb2coJyVPJywgJHNjb3BlLnN0b3JpZXNbMF0pO1xuICAgIC8vIGxldCBldmVyeXRoaW5nIGtub3cgd2UgYXJlIGRvbmUgbG9hZGluZ1xuICAgICRzY29wZS4kZW1pdCgnTE9BRERPTkUnKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgc3RvcmllcyB0aGUgZmlyc3QgdGltZVxuICBzdG9yeUxpc3QuZ2V0KCRzY29wZSk7XG5cbiAgLy8gZ2V0TW9yZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBkaXYgaXMgc2Nyb2xsZWRcblx0JHNjb3BlLmdldE1vcmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaWYgcGFnZSBwb3NpdGlvbiBpcyBiaWdnZXIgdGhhbiA4OCBcblx0XHQvLyBmZXRjaCBtb3JlIHN0b3JpZXNcblx0XHRpZiAoISRzY29wZS5mZXRjaGluZykge1xuICAgICAgJHNjb3BlLiRlbWl0KCdMT0FEJyk7XG4gICAgICAkc2NvcGUuY291bnQgPSAoJHNjb3BlLmNvdW50ID09PSA2MCkgPyA2MCA6ICRzY29wZS5jb3VudCArIDE1O1xuXHRcdFx0Ly8gbGV0IGV2ZXJ5dGhpbmcga25vdyB3ZSBhcmUgbG9hZGluZ1xuICAgICAgc3RvcnlMaXN0LmdldCgkc2NvcGUpO1xuXG5cdFx0fVxuXHR9XG5cbiAgJHNjb3BlLnN0b3J5U3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gc2V0IHRoZSBkYXRhIGhlcmUgdG8gdGhlIGV4cGFuZGluZyBkaXYgZm9yIHRoZSBzdG9yeVxuICAgIC8vIGNvbnNvbGUubG9nKCclbycsICRzY29wZS5zdG9yaWVzKTtcbiAgICAkc2NvcGUuc3Rvcmllc1skc2NvcGUuc3RvcnlJZF1bJ3N0b3J5Q29udGVudCddID0gZGF0YS5zdG9yeVswXTtcbiAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgfVxuXG5cbiAgJHNjb3BlLnN0b3J5Q2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY29uc29sZS5sb2coJyVvJyx0aGlzLiRpbmRleClcbiAgICAkc2NvcGUuc2x1ZyA9IHRoaXMuc3RvcnkuaWQ7XG4gICAgJHNjb3BlLnN0b3J5SWQgPSB0aGlzLiRpbmRleDtcbiAgICBzdG9yeS5nZXQoJHNjb3BlKTtcbiAgfVxuXG5cbn1cblxuXG4vLyBBc3NpZ24gaW5mU2Nyb2xsQ29udHJvbGxlciBhcyBhbiBhbmd1bGFyIGNvbnRyb2xsZXIgXG4vLyBpbiBhIG1hbm5lciBzYWZlIGZvciBtaW5pZmljYXRpb25cbmluZnNjci5jb250cm9sbGVyKCdpbmZTY3JvbGxDdHJsJywgWyckc2NvcGUnLCAnJHdpbmRvdycsICdnZXRTdG9yeUxpc3QnLCAnZ2V0U3RvcnlDb250ZW50JywgaW5mU2Nyb2xsQ29udHJvbGxlcl0pO1xuXG5cblxuXG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgVEhFQ09ERSA9IFszOCwzOCw0MCw0MCwzNywzOSwzNywzOSw2Niw2NV07XG5cbiAgdmFyIHRlc3Rjb2RlID0gW107XG4gIHZhciB0aW1lO1xuXG4gIC8vIGsgY29kZSBzdHVmZlxuICBmdW5jdGlvbiBjaGVja0tleXMgKGUpIHtcbiAgICB2YXIgYnV0dG9uID0gKGUua2V5Q29kZSk7XG5cbiAgICBpZiAoVEhFQ09ERS5pbmRleE9mKGJ1dHRvbikgPiAtMSkge1xuICAgICAgdGVzdGNvZGVbdGVzdGNvZGUubGVuZ3RoXSA9IGUua2V5Q29kZTtcblxuICAgICAgaWYgKHRlc3Rjb2RlLmxlbmd0aCA9PT0gVEhFQ09ERS5sZW5ndGgpIHtcbiAgICAgICAgY2hlY2tDb2RlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhckNvZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NvZGUgKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVEhFQ09ERS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFRIRUNPREVbaV0gIT09IHRlc3Rjb2RlW2ldKSB7XG4gICAgICAgIHRlc3Rjb2RlID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVzdGNvZGUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ2R1ZiB0aW1lIScpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQ29kZSAoKSB7XG4gICAgaWYgKHRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZSA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0ZXN0Y29kZSA9IFtdO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWUpO1xuICAgICAgfSwgMTAwMDApO1xuICAgIH1cbiAgfVxuXG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleXMpO1xufSkoKVxuXG5cbn0pKGFuZ3VsYXIpOyJdfQ==
