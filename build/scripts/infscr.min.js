(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./src/scripts/infscr.js":[function(require,module,exports){
(function (angular) {
var infscr = angular.module('infscr', []);

infscr.config(function ($httpProvider) {
	delete $httpProvider.defaults.headers.common['X-Requested-With'];
});


// scrollDiv defines the object to be used as a directive
function scrollDiv ($window) {
  'use strict';

  // this function loads on the defined element
  return function (scope, element, attrs) {
      // position starts at 0
      scope.position = 0;

      // wait for the LOADDONE event
      scope.$on('LOADDONE', function (event) {
        scope.position = Math.floor(((window.pageYOffset + $(window).height()) / $(document).height()) * 100);
        
        angular.element(window).bind('scroll', function () {          
          scope.position = Math.floor(((this.pageYOffset + $(window).height()) / $(document).height()) * 100);
          if (scope.position > 85) {
            scope.getMore();
          }
          scope.$apply();
        });

        if (scope.count >= 60) {
          angular.element(window).unbind('scroll');
        }
      });

    }
}

// assign scrollDiv to a directive
// in a minification safe manner
infscr.directive('scrollDiv', ['$window', scrollDiv]);






// The getStoryList function uses angularjs' $http
// object to make xhr's to get stories
function getStoryList ($http) {

  // the url to request stories from
  var url = 'http://golfweek.com/json/';

  return {
    // the get function should suffice for most normal uses
    // it accepts a context object to get info about the sections
    // ctx also needs a success function to return the data
    get: function (ctx) {
      // the category function is here for future use with sections and sub sections
      // currently it is not used
      var category = (ctx.section === undefined) ? '' : ctx.section;
      category += (ctx.sub === undefined || ctx.sub === 'all') ? '' : '/' + ctx.sub;
      category += (ctx.subsub === undefined) ? '' : '/' + ctx.subsub;
      category += (ctx.subsubsub === undefined) ? '' : '/' + ctx.subsubsub;
      
      // the count is at minimum 15 but must be in increments of 15 currently
      var count = (ctx.count === undefined) ? 15 : ctx.count;
      
      // make the request to golfweek 
      // ***MUST BE A POST OR ELLINGTON BLOCKS IT***
      $http.post(url + 'section/?Section=' + category + '&Num=' + count)
        .success(function (data) {  
          ctx.success(data);
        })
        .error(function (data, status) {
          console.log(data, status);
        });
    }
  }
}


// Assign getStoryList as an angular factory 
// in a manner safe for minification
infscr.factory('getStoryList', ['$http', getStoryList]);



// the getStoryContent function is intended to load the clicked
// story into the selected div
function getStoryContent ($http) {
  
  // the base url to request the storydata from
  var url = 'http://golfweek.com/';

  return {
    get: function (ctx) {      
      $http.post(url + ctx.slug + '?json')
        .success(function (data) {
          ctx.storySuccess(data);
        })
        .error(function (data, status) {
          console.log(data, status);
        });
    }
  }
}


// Assign getStoryList as an angular factory 
// in a manner safe for minification
infscr.factory('getStoryContent', ['$http', getStoryContent]);



// the infScrollController function is intended to be used 
// in the div where the stories should be added for infinite 
// scrolling
function infScrollController ($scope, $window, storyList, story) {
	$scope.count = 15;  // number of stories to get
	$scope.fetching = false; // are we fetching right now?
  $scope.stories = []; // starts out as an empty array

  $scope.$on('LOAD', function (e) { $scope.fetching = true; });
  $scope.$on('LOADDONE', function (e) { $scope.fetching = false; });

  // this is the success handler when data is received
  $scope.success = function (data) {
    angular.forEach(data.stories, function (val, key) {
      this[key] = val;
    }, $scope.stories);
    // console.log('%O', $scope.stories[0]);
    // let everything know we are done loading
    $scope.$emit('LOADDONE');
  }

  // get the stories the first time
  storyList.get($scope);

  // getMore should be used when the div is scrolled
	$scope.getMore = function () {
		// if page position is bigger than 88 
		// fetch more stories
		if (!$scope.fetching) {
      $scope.$emit('LOAD');
      $scope.count = ($scope.count === 60) ? 60 : $scope.count + 15;
			// let everything know we are loading
      storyList.get($scope);

		}
	}

  $scope.storySuccess = function (data) {
    // set the data here to the expanding div for the story
    // console.log('%o', $scope.stories);
    $scope.stories[$scope.storyId]['storyContent'] = data.story[0];
    console.log(data);
  }


  $scope.storyClick = function () {
    // console.log('%o',this.$index)
    $scope.slug = this.story.id;
    $scope.storyId = this.$index;
    story.get($scope);
  }


}


// Assign infScrollController as an angular controller 
// in a manner safe for minification
infscr.controller('infScrollCtrl', ['$scope', '$window', 'getStoryList', 'getStoryContent', infScrollController]);



var storyList = {};
var storyCount = 15;

function bindModelInput(obj, property, domElem) {
  Object.defineProperty(obj, property, {
    get: function() { return domElem.value; }, 
    set: function(newValue) { domElem.value = newValue; },
    configurable: true
  });
}






(function () {

  var THECODE = [38,38,40,40,37,39,37,39,66,65];

  var testcode = [];
  var time;

  // k code stuff
  function checkKeys (e) {
    var button = (e.keyCode);

    if (THECODE.indexOf(button) > -1) {
      testcode[testcode.length] = e.keyCode;

      if (testcode.length === THECODE.length) {
        checkCode();
      } else {
        clearCode();
      }
    }
  }

  function checkCode () {
    for (var i = 0; i < THECODE.length; i++) {
      if (THECODE[i] !== testcode[i]) {
        testcode = [];
        break;
      }
    }
    if (testcode.length > 0) {
      console.log('duf time!');
    }
  }

  function clearCode () {
    if (time === undefined) {
      time = window.setTimeout(function() {
        testcode = [];
        window.clearTimeout(time);
      }, 10000);
    }
  }


  window.addEventListener('keydown', checkKeys);
})()


})(angular);
},{}]},{},["./src/scripts/infscr.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuL3NyYy9zY3JpcHRzL2luZnNjci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIChhbmd1bGFyKSB7XG52YXIgaW5mc2NyID0gYW5ndWxhci5tb2R1bGUoJ2luZnNjcicsIFtdKTtcblxuaW5mc2NyLmNvbmZpZyhmdW5jdGlvbiAoJGh0dHBQcm92aWRlcikge1xuXHRkZWxldGUgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnWC1SZXF1ZXN0ZWQtV2l0aCddO1xufSk7XG5cblxuLy8gc2Nyb2xsRGl2IGRlZmluZXMgdGhlIG9iamVjdCB0byBiZSB1c2VkIGFzIGEgZGlyZWN0aXZlXG5mdW5jdGlvbiBzY3JvbGxEaXYgKCR3aW5kb3cpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHRoaXMgZnVuY3Rpb24gbG9hZHMgb24gdGhlIGRlZmluZWQgZWxlbWVudFxuICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgLy8gcG9zaXRpb24gc3RhcnRzIGF0IDBcbiAgICAgIHNjb3BlLnBvc2l0aW9uID0gMDtcblxuICAgICAgLy8gd2FpdCBmb3IgdGhlIExPQURET05FIGV2ZW50XG4gICAgICBzY29wZS4kb24oJ0xPQURET05FJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNjb3BlLnBvc2l0aW9uID0gTWF0aC5mbG9vcigoKHdpbmRvdy5wYWdlWU9mZnNldCArICQod2luZG93KS5oZWlnaHQoKSkgLyAkKGRvY3VtZW50KS5oZWlnaHQoKSkgKiAxMDApO1xuICAgICAgICBcbiAgICAgICAgYW5ndWxhci5lbGVtZW50KHdpbmRvdykuYmluZCgnc2Nyb2xsJywgZnVuY3Rpb24gKCkgeyAgICAgICAgICBcbiAgICAgICAgICBzY29wZS5wb3NpdGlvbiA9IE1hdGguZmxvb3IoKCh0aGlzLnBhZ2VZT2Zmc2V0ICsgJCh3aW5kb3cpLmhlaWdodCgpKSAvICQoZG9jdW1lbnQpLmhlaWdodCgpKSAqIDEwMCk7XG4gICAgICAgICAgaWYgKHNjb3BlLnBvc2l0aW9uID4gODUpIHtcbiAgICAgICAgICAgIHNjb3BlLmdldE1vcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzY29wZS5jb3VudCA+PSA2MCkge1xuICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudCh3aW5kb3cpLnVuYmluZCgnc2Nyb2xsJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfVxufVxuXG4vLyBhc3NpZ24gc2Nyb2xsRGl2IHRvIGEgZGlyZWN0aXZlXG4vLyBpbiBhIG1pbmlmaWNhdGlvbiBzYWZlIG1hbm5lclxuaW5mc2NyLmRpcmVjdGl2ZSgnc2Nyb2xsRGl2JywgWyckd2luZG93Jywgc2Nyb2xsRGl2XSk7XG5cblxuXG5cblxuXG4vLyBUaGUgZ2V0U3RvcnlMaXN0IGZ1bmN0aW9uIHVzZXMgYW5ndWxhcmpzJyAkaHR0cFxuLy8gb2JqZWN0IHRvIG1ha2UgeGhyJ3MgdG8gZ2V0IHN0b3JpZXNcbmZ1bmN0aW9uIGdldFN0b3J5TGlzdCAoJGh0dHApIHtcblxuICAvLyB0aGUgdXJsIHRvIHJlcXVlc3Qgc3RvcmllcyBmcm9tXG4gIHZhciB1cmwgPSAnaHR0cDovL2dvbGZ3ZWVrLmNvbS9qc29uLyc7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyB0aGUgZ2V0IGZ1bmN0aW9uIHNob3VsZCBzdWZmaWNlIGZvciBtb3N0IG5vcm1hbCB1c2VzXG4gICAgLy8gaXQgYWNjZXB0cyBhIGNvbnRleHQgb2JqZWN0IHRvIGdldCBpbmZvIGFib3V0IHRoZSBzZWN0aW9uc1xuICAgIC8vIGN0eCBhbHNvIG5lZWRzIGEgc3VjY2VzcyBmdW5jdGlvbiB0byByZXR1cm4gdGhlIGRhdGFcbiAgICBnZXQ6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIC8vIHRoZSBjYXRlZ29yeSBmdW5jdGlvbiBpcyBoZXJlIGZvciBmdXR1cmUgdXNlIHdpdGggc2VjdGlvbnMgYW5kIHN1YiBzZWN0aW9uc1xuICAgICAgLy8gY3VycmVudGx5IGl0IGlzIG5vdCB1c2VkXG4gICAgICB2YXIgY2F0ZWdvcnkgPSAoY3R4LnNlY3Rpb24gPT09IHVuZGVmaW5lZCkgPyAnJyA6IGN0eC5zZWN0aW9uO1xuICAgICAgY2F0ZWdvcnkgKz0gKGN0eC5zdWIgPT09IHVuZGVmaW5lZCB8fCBjdHguc3ViID09PSAnYWxsJykgPyAnJyA6ICcvJyArIGN0eC5zdWI7XG4gICAgICBjYXRlZ29yeSArPSAoY3R4LnN1YnN1YiA9PT0gdW5kZWZpbmVkKSA/ICcnIDogJy8nICsgY3R4LnN1YnN1YjtcbiAgICAgIGNhdGVnb3J5ICs9IChjdHguc3Vic3Vic3ViID09PSB1bmRlZmluZWQpID8gJycgOiAnLycgKyBjdHguc3Vic3Vic3ViO1xuICAgICAgXG4gICAgICAvLyB0aGUgY291bnQgaXMgYXQgbWluaW11bSAxNSBidXQgbXVzdCBiZSBpbiBpbmNyZW1lbnRzIG9mIDE1IGN1cnJlbnRseVxuICAgICAgdmFyIGNvdW50ID0gKGN0eC5jb3VudCA9PT0gdW5kZWZpbmVkKSA/IDE1IDogY3R4LmNvdW50O1xuICAgICAgXG4gICAgICAvLyBtYWtlIHRoZSByZXF1ZXN0IHRvIGdvbGZ3ZWVrIFxuICAgICAgLy8gKioqTVVTVCBCRSBBIFBPU1QgT1IgRUxMSU5HVE9OIEJMT0NLUyBJVCoqKlxuICAgICAgJGh0dHAucG9zdCh1cmwgKyAnc2VjdGlvbi8/U2VjdGlvbj0nICsgY2F0ZWdvcnkgKyAnJk51bT0nICsgY291bnQpXG4gICAgICAgIC5zdWNjZXNzKGZ1bmN0aW9uIChkYXRhKSB7ICBcbiAgICAgICAgICBjdHguc3VjY2VzcyhkYXRhKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmVycm9yKGZ1bmN0aW9uIChkYXRhLCBzdGF0dXMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhLCBzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBBc3NpZ24gZ2V0U3RvcnlMaXN0IGFzIGFuIGFuZ3VsYXIgZmFjdG9yeSBcbi8vIGluIGEgbWFubmVyIHNhZmUgZm9yIG1pbmlmaWNhdGlvblxuaW5mc2NyLmZhY3RvcnkoJ2dldFN0b3J5TGlzdCcsIFsnJGh0dHAnLCBnZXRTdG9yeUxpc3RdKTtcblxuXG5cbi8vIHRoZSBnZXRTdG9yeUNvbnRlbnQgZnVuY3Rpb24gaXMgaW50ZW5kZWQgdG8gbG9hZCB0aGUgY2xpY2tlZFxuLy8gc3RvcnkgaW50byB0aGUgc2VsZWN0ZWQgZGl2XG5mdW5jdGlvbiBnZXRTdG9yeUNvbnRlbnQgKCRodHRwKSB7XG4gIFxuICAvLyB0aGUgYmFzZSB1cmwgdG8gcmVxdWVzdCB0aGUgc3RvcnlkYXRhIGZyb21cbiAgdmFyIHVybCA9ICdodHRwOi8vZ29sZndlZWsuY29tLyc7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIChjdHgpIHsgICAgICBcbiAgICAgICRodHRwLnBvc3QodXJsICsgY3R4LnNsdWcgKyAnP2pzb24nKVxuICAgICAgICAuc3VjY2VzcyhmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGN0eC5zdG9yeVN1Y2Nlc3MoZGF0YSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5lcnJvcihmdW5jdGlvbiAoZGF0YSwgc3RhdHVzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZGF0YSwgc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cblxuLy8gQXNzaWduIGdldFN0b3J5TGlzdCBhcyBhbiBhbmd1bGFyIGZhY3RvcnkgXG4vLyBpbiBhIG1hbm5lciBzYWZlIGZvciBtaW5pZmljYXRpb25cbmluZnNjci5mYWN0b3J5KCdnZXRTdG9yeUNvbnRlbnQnLCBbJyRodHRwJywgZ2V0U3RvcnlDb250ZW50XSk7XG5cblxuXG4vLyB0aGUgaW5mU2Nyb2xsQ29udHJvbGxlciBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIFxuLy8gaW4gdGhlIGRpdiB3aGVyZSB0aGUgc3RvcmllcyBzaG91bGQgYmUgYWRkZWQgZm9yIGluZmluaXRlIFxuLy8gc2Nyb2xsaW5nXG5mdW5jdGlvbiBpbmZTY3JvbGxDb250cm9sbGVyICgkc2NvcGUsICR3aW5kb3csIHN0b3J5TGlzdCwgc3RvcnkpIHtcblx0JHNjb3BlLmNvdW50ID0gMTU7ICAvLyBudW1iZXIgb2Ygc3RvcmllcyB0byBnZXRcblx0JHNjb3BlLmZldGNoaW5nID0gZmFsc2U7IC8vIGFyZSB3ZSBmZXRjaGluZyByaWdodCBub3c/XG4gICRzY29wZS5zdG9yaWVzID0gW107IC8vIHN0YXJ0cyBvdXQgYXMgYW4gZW1wdHkgYXJyYXlcblxuICAkc2NvcGUuJG9uKCdMT0FEJywgZnVuY3Rpb24gKGUpIHsgJHNjb3BlLmZldGNoaW5nID0gdHJ1ZTsgfSk7XG4gICRzY29wZS4kb24oJ0xPQURET05FJywgZnVuY3Rpb24gKGUpIHsgJHNjb3BlLmZldGNoaW5nID0gZmFsc2U7IH0pO1xuXG4gIC8vIHRoaXMgaXMgdGhlIHN1Y2Nlc3MgaGFuZGxlciB3aGVuIGRhdGEgaXMgcmVjZWl2ZWRcbiAgJHNjb3BlLnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLnN0b3JpZXMsIGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgdGhpc1trZXldID0gdmFsO1xuICAgIH0sICRzY29wZS5zdG9yaWVzKTtcbiAgICAvLyBjb25zb2xlLmxvZygnJU8nLCAkc2NvcGUuc3Rvcmllc1swXSk7XG4gICAgLy8gbGV0IGV2ZXJ5dGhpbmcga25vdyB3ZSBhcmUgZG9uZSBsb2FkaW5nXG4gICAgJHNjb3BlLiRlbWl0KCdMT0FERE9ORScpO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBzdG9yaWVzIHRoZSBmaXJzdCB0aW1lXG4gIHN0b3J5TGlzdC5nZXQoJHNjb3BlKTtcblxuICAvLyBnZXRNb3JlIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIGRpdiBpcyBzY3JvbGxlZFxuXHQkc2NvcGUuZ2V0TW9yZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBpZiBwYWdlIHBvc2l0aW9uIGlzIGJpZ2dlciB0aGFuIDg4IFxuXHRcdC8vIGZldGNoIG1vcmUgc3Rvcmllc1xuXHRcdGlmICghJHNjb3BlLmZldGNoaW5nKSB7XG4gICAgICAkc2NvcGUuJGVtaXQoJ0xPQUQnKTtcbiAgICAgICRzY29wZS5jb3VudCA9ICgkc2NvcGUuY291bnQgPT09IDYwKSA/IDYwIDogJHNjb3BlLmNvdW50ICsgMTU7XG5cdFx0XHQvLyBsZXQgZXZlcnl0aGluZyBrbm93IHdlIGFyZSBsb2FkaW5nXG4gICAgICBzdG9yeUxpc3QuZ2V0KCRzY29wZSk7XG5cblx0XHR9XG5cdH1cblxuICAkc2NvcGUuc3RvcnlTdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyBzZXQgdGhlIGRhdGEgaGVyZSB0byB0aGUgZXhwYW5kaW5nIGRpdiBmb3IgdGhlIHN0b3J5XG4gICAgLy8gY29uc29sZS5sb2coJyVvJywgJHNjb3BlLnN0b3JpZXMpO1xuICAgICRzY29wZS5zdG9yaWVzWyRzY29wZS5zdG9yeUlkXVsnc3RvcnlDb250ZW50J10gPSBkYXRhLnN0b3J5WzBdO1xuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICB9XG5cblxuICAkc2NvcGUuc3RvcnlDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnJW8nLHRoaXMuJGluZGV4KVxuICAgICRzY29wZS5zbHVnID0gdGhpcy5zdG9yeS5pZDtcbiAgICAkc2NvcGUuc3RvcnlJZCA9IHRoaXMuJGluZGV4O1xuICAgIHN0b3J5LmdldCgkc2NvcGUpO1xuICB9XG5cblxufVxuXG5cbi8vIEFzc2lnbiBpbmZTY3JvbGxDb250cm9sbGVyIGFzIGFuIGFuZ3VsYXIgY29udHJvbGxlciBcbi8vIGluIGEgbWFubmVyIHNhZmUgZm9yIG1pbmlmaWNhdGlvblxuaW5mc2NyLmNvbnRyb2xsZXIoJ2luZlNjcm9sbEN0cmwnLCBbJyRzY29wZScsICckd2luZG93JywgJ2dldFN0b3J5TGlzdCcsICdnZXRTdG9yeUNvbnRlbnQnLCBpbmZTY3JvbGxDb250cm9sbGVyXSk7XG5cblxuXG52YXIgc3RvcnlMaXN0ID0ge307XG52YXIgc3RvcnlDb3VudCA9IDE1O1xuXG5mdW5jdGlvbiBiaW5kTW9kZWxJbnB1dChvYmosIHByb3BlcnR5LCBkb21FbGVtKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGRvbUVsZW0udmFsdWU7IH0sIFxuICAgIHNldDogZnVuY3Rpb24obmV3VmFsdWUpIHsgZG9tRWxlbS52YWx1ZSA9IG5ld1ZhbHVlOyB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuXG5cblxuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIFRIRUNPREUgPSBbMzgsMzgsNDAsNDAsMzcsMzksMzcsMzksNjYsNjVdO1xuXG4gIHZhciB0ZXN0Y29kZSA9IFtdO1xuICB2YXIgdGltZTtcblxuICAvLyBrIGNvZGUgc3R1ZmZcbiAgZnVuY3Rpb24gY2hlY2tLZXlzIChlKSB7XG4gICAgdmFyIGJ1dHRvbiA9IChlLmtleUNvZGUpO1xuXG4gICAgaWYgKFRIRUNPREUuaW5kZXhPZihidXR0b24pID4gLTEpIHtcbiAgICAgIHRlc3Rjb2RlW3Rlc3Rjb2RlLmxlbmd0aF0gPSBlLmtleUNvZGU7XG5cbiAgICAgIGlmICh0ZXN0Y29kZS5sZW5ndGggPT09IFRIRUNPREUubGVuZ3RoKSB7XG4gICAgICAgIGNoZWNrQ29kZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJDb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDb2RlICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRIRUNPREUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChUSEVDT0RFW2ldICE9PSB0ZXN0Y29kZVtpXSkge1xuICAgICAgICB0ZXN0Y29kZSA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlc3Rjb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdkdWYgdGltZSEnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckNvZGUgKCkge1xuICAgIGlmICh0aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWUgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGVzdGNvZGUgPSBbXTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lKTtcbiAgICAgIH0sIDEwMDAwKTtcbiAgICB9XG4gIH1cblxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXlzKTtcbn0pKClcblxuXG59KShhbmd1bGFyKTsiXX0=
