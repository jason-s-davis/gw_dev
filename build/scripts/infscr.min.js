(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./src/scripts/infscr.js":[function(require,module,exports){
(function (angular) {
var infscr = angular.module('infscr', []);

infscr.config(function ($httpProvider) {
	delete $httpProvider.defaults.headers.common['X-Requested-With'];
});


// scrollDiv defines the object to be used as a directive
function scrollDiv ($window) {
  'use strict';

  // this function loads on the defined element
  return function (scope, element, attrs) {
      // position starts at 0
      scope.position = 0;

      // wait for the LOADDONE event
      scope.$on('LOADDONE', function (event) {
        scope.position = Math.floor(((window.pageYOffset + $(window).height()) / $(document).height()) * 100);
        
        angular.element(window).bind('scroll', function () {          
          scope.position = Math.floor(((this.pageYOffset + $(window).height()) / $(document).height()) * 100);
          if (scope.position > 85) {
            scope.getMore();
          }
          scope.$apply();
        });

        if (scope.count >= 60) {
          angular.element(window).unbind('scroll');
        }
      });

    }
}

// assign scrollDiv to a directive
// in a minification safe manner
infscr.directive('scrollDiv', ['$window', scrollDiv]);






// The getStoryList function uses angularjs' $http
// object to make xhr's to get stories
function getStoryList ($http) {

  // the url to request stories from
  var url = 'http://golfweek.com/json/';

  return {
    // the get function should suffice for most normal uses
    // it accepts a context object to get info about the sections
    // ctx also needs a success function to return the data
    get: function (ctx) {
      // the category function is here for future use with sections and sub sections
      // currently it is not used
      var category = (ctx.section === undefined) ? '' : ctx.section;
      category += (ctx.sub === undefined || ctx.sub === 'all') ? '' : '/' + ctx.sub;
      category += (ctx.subsub === undefined) ? '' : '/' + ctx.subsub;
      category += (ctx.subsubsub === undefined) ? '' : '/' + ctx.subsubsub;
      
      // the count is at minimum 15 but must be in increments of 15 currently
      var count = (ctx.count === undefined) ? 15 : ctx.count;
      
      // make the request to golfweek 
      // ***MUST BE A POST OR ELLINGTON BLOCKS IT***
      $http.post(url + 'section/?Section=' + category + '&Num=' + count)
        .success(function (data) {  
          ctx.success(data);
        })
        .error(function (data, status) {
          console.log(data, status);
        });
    }
  }
}


// Assign getStoryList as an angular factory 
// in a manner safe for minification
infscr.factory('getStoryList', ['$http', getStoryList]);



// the getStoryContent function is intended to load the clicked
// story into the selected div
function getStoryContent ($http) {
  
  // the base url to request the storydata from
  var url = 'http://golfweek.com/';

  return {
    get: function (ctx) {      
      $http.post(url + ctx.slug + '?json')
        .success(function (data) {
          ctx.storySuccess(data);
        })
        .error(function (data, status) {
          console.log(data, status);
        });
    }
  }
}


// Assign getStoryList as an angular factory 
// in a manner safe for minification
infscr.factory('getStoryContent', ['$http', getStoryContent]);



// the infScrollController function is intended to be used 
// in the div where the stories should be added for infinite 
// scrolling
function infScrollController ($scope, $window, storyList, story) {
	$scope.count = 15;  // number of stories to get
	$scope.fetching = false; // are we fetching right now?
  $scope.stories = []; // starts out as an empty array

  $scope.$on('LOAD', function (e) { $scope.fetching = true; });
  $scope.$on('LOADDONE', function (e) { $scope.fetching = false; });

  // this is the success handler when data is received
  $scope.success = function (data) {
    angular.forEach(data.stories, function (val, key) {
      this[key] = val;
    }, $scope.stories);
    // console.log('%O', $scope.stories[0]);
    // let everything know we are done loading
    $scope.$emit('LOADDONE');
  }

  // get the stories the first time
  storyList.get($scope);

  // getMore should be used when the div is scrolled
	$scope.getMore = function () {
		// if page position is bigger than 88 
		// fetch more stories
		if (!$scope.fetching) {
      $scope.$emit('LOAD');
      $scope.count = ($scope.count === 60) ? 60 : $scope.count + 15;
			// let everything know we are loading
      storyList.get($scope);

		}
	}

  $scope.storySuccess = function (data) {
    // set the data here to the expanding div for the story
    // console.log('%o', $scope.stories);
    $scope.stories[$scope.storyId]['storyContent'] = data.story[0];
    console.log(data);
  }


  $scope.storyClick = function () {
    // console.log('%o',this.$index)
    $scope.slug = this.story.id;
    $scope.storyId = this.$index;
    story.get($scope);
  }


}


// Assign infScrollController as an angular controller 
// in a manner safe for minification
infscr.controller('infScrollCtrl', ['$scope', '$window', 'getStoryList', 'getStoryContent', infScrollController]);






(function () {

  var THECODE = [38,38,40,40,37,39,37,39,66,65];

  var testcode = [];
  var time;

  // k code stuff
  function checkKeys (e) {
    var button = (e.keyCode);

    if (THECODE.indexOf(button) > -1) {
      testcode[testcode.length] = e.keyCode;

      if (testcode.length === THECODE.length) {
        checkCode();
      } else {
        clearCode();
      }
    }
  }

  function checkCode () {
    for (var i = 0; i < THECODE.length; i++) {
      if (THECODE[i] !== testcode[i]) {
        testcode = [];
        break;
      }
    }
    if (testcode.length > 0) {
      console.log('duf time!');
    }
  }

  function clearCode () {
    if (time === undefined) {
      time = window.setTimeout(function() {
        testcode = [];
        window.clearTimeout(time);
      }, 10000);
    }
  }


  window.addEventListener('keydown', checkKeys);
})()

})(angular);
},{}]},{},["./src/scripts/infscr.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuL3NyYy9zY3JpcHRzL2luZnNjci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKGFuZ3VsYXIpIHtcbnZhciBpbmZzY3IgPSBhbmd1bGFyLm1vZHVsZSgnaW5mc2NyJywgW10pO1xuXG5pbmZzY3IuY29uZmlnKGZ1bmN0aW9uICgkaHR0cFByb3ZpZGVyKSB7XG5cdGRlbGV0ZSAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydYLVJlcXVlc3RlZC1XaXRoJ107XG59KTtcblxuXG4vLyBzY3JvbGxEaXYgZGVmaW5lcyB0aGUgb2JqZWN0IHRvIGJlIHVzZWQgYXMgYSBkaXJlY3RpdmVcbmZ1bmN0aW9uIHNjcm9sbERpdiAoJHdpbmRvdykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gdGhpcyBmdW5jdGlvbiBsb2FkcyBvbiB0aGUgZGVmaW5lZCBlbGVtZW50XG4gIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAvLyBwb3NpdGlvbiBzdGFydHMgYXQgMFxuICAgICAgc2NvcGUucG9zaXRpb24gPSAwO1xuXG4gICAgICAvLyB3YWl0IGZvciB0aGUgTE9BRERPTkUgZXZlbnRcbiAgICAgIHNjb3BlLiRvbignTE9BRERPTkUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc2NvcGUucG9zaXRpb24gPSBNYXRoLmZsb29yKCgod2luZG93LnBhZ2VZT2Zmc2V0ICsgJCh3aW5kb3cpLmhlaWdodCgpKSAvICQoZG9jdW1lbnQpLmhlaWdodCgpKSAqIDEwMCk7XG4gICAgICAgIFxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQod2luZG93KS5iaW5kKCdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgIFxuICAgICAgICAgIHNjb3BlLnBvc2l0aW9uID0gTWF0aC5mbG9vcigoKHRoaXMucGFnZVlPZmZzZXQgKyAkKHdpbmRvdykuaGVpZ2h0KCkpIC8gJChkb2N1bWVudCkuaGVpZ2h0KCkpICogMTAwKTtcbiAgICAgICAgICBpZiAoc2NvcGUucG9zaXRpb24gPiA4NSkge1xuICAgICAgICAgICAgc2NvcGUuZ2V0TW9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNjb3BlLmNvdW50ID49IDYwKSB7XG4gICAgICAgICAgYW5ndWxhci5lbGVtZW50KHdpbmRvdykudW5iaW5kKCdzY3JvbGwnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9XG59XG5cbi8vIGFzc2lnbiBzY3JvbGxEaXYgdG8gYSBkaXJlY3RpdmVcbi8vIGluIGEgbWluaWZpY2F0aW9uIHNhZmUgbWFubmVyXG5pbmZzY3IuZGlyZWN0aXZlKCdzY3JvbGxEaXYnLCBbJyR3aW5kb3cnLCBzY3JvbGxEaXZdKTtcblxuXG5cblxuXG5cbi8vIFRoZSBnZXRTdG9yeUxpc3QgZnVuY3Rpb24gdXNlcyBhbmd1bGFyanMnICRodHRwXG4vLyBvYmplY3QgdG8gbWFrZSB4aHIncyB0byBnZXQgc3Rvcmllc1xuZnVuY3Rpb24gZ2V0U3RvcnlMaXN0ICgkaHR0cCkge1xuXG4gIC8vIHRoZSB1cmwgdG8gcmVxdWVzdCBzdG9yaWVzIGZyb21cbiAgdmFyIHVybCA9ICdodHRwOi8vZ29sZndlZWsuY29tL2pzb24vJztcblxuICByZXR1cm4ge1xuICAgIC8vIHRoZSBnZXQgZnVuY3Rpb24gc2hvdWxkIHN1ZmZpY2UgZm9yIG1vc3Qgbm9ybWFsIHVzZXNcbiAgICAvLyBpdCBhY2NlcHRzIGEgY29udGV4dCBvYmplY3QgdG8gZ2V0IGluZm8gYWJvdXQgdGhlIHNlY3Rpb25zXG4gICAgLy8gY3R4IGFsc28gbmVlZHMgYSBzdWNjZXNzIGZ1bmN0aW9uIHRvIHJldHVybiB0aGUgZGF0YVxuICAgIGdldDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgLy8gdGhlIGNhdGVnb3J5IGZ1bmN0aW9uIGlzIGhlcmUgZm9yIGZ1dHVyZSB1c2Ugd2l0aCBzZWN0aW9ucyBhbmQgc3ViIHNlY3Rpb25zXG4gICAgICAvLyBjdXJyZW50bHkgaXQgaXMgbm90IHVzZWRcbiAgICAgIHZhciBjYXRlZ29yeSA9IChjdHguc2VjdGlvbiA9PT0gdW5kZWZpbmVkKSA/ICcnIDogY3R4LnNlY3Rpb247XG4gICAgICBjYXRlZ29yeSArPSAoY3R4LnN1YiA9PT0gdW5kZWZpbmVkIHx8IGN0eC5zdWIgPT09ICdhbGwnKSA/ICcnIDogJy8nICsgY3R4LnN1YjtcbiAgICAgIGNhdGVnb3J5ICs9IChjdHguc3Vic3ViID09PSB1bmRlZmluZWQpID8gJycgOiAnLycgKyBjdHguc3Vic3ViO1xuICAgICAgY2F0ZWdvcnkgKz0gKGN0eC5zdWJzdWJzdWIgPT09IHVuZGVmaW5lZCkgPyAnJyA6ICcvJyArIGN0eC5zdWJzdWJzdWI7XG4gICAgICBcbiAgICAgIC8vIHRoZSBjb3VudCBpcyBhdCBtaW5pbXVtIDE1IGJ1dCBtdXN0IGJlIGluIGluY3JlbWVudHMgb2YgMTUgY3VycmVudGx5XG4gICAgICB2YXIgY291bnQgPSAoY3R4LmNvdW50ID09PSB1bmRlZmluZWQpID8gMTUgOiBjdHguY291bnQ7XG4gICAgICBcbiAgICAgIC8vIG1ha2UgdGhlIHJlcXVlc3QgdG8gZ29sZndlZWsgXG4gICAgICAvLyAqKipNVVNUIEJFIEEgUE9TVCBPUiBFTExJTkdUT04gQkxPQ0tTIElUKioqXG4gICAgICAkaHR0cC5wb3N0KHVybCArICdzZWN0aW9uLz9TZWN0aW9uPScgKyBjYXRlZ29yeSArICcmTnVtPScgKyBjb3VudClcbiAgICAgICAgLnN1Y2Nlc3MoZnVuY3Rpb24gKGRhdGEpIHsgIFxuICAgICAgICAgIGN0eC5zdWNjZXNzKGRhdGEpO1xuICAgICAgICB9KVxuICAgICAgICAuZXJyb3IoZnVuY3Rpb24gKGRhdGEsIHN0YXR1cykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEsIHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5cbi8vIEFzc2lnbiBnZXRTdG9yeUxpc3QgYXMgYW4gYW5ndWxhciBmYWN0b3J5IFxuLy8gaW4gYSBtYW5uZXIgc2FmZSBmb3IgbWluaWZpY2F0aW9uXG5pbmZzY3IuZmFjdG9yeSgnZ2V0U3RvcnlMaXN0JywgWyckaHR0cCcsIGdldFN0b3J5TGlzdF0pO1xuXG5cblxuLy8gdGhlIGdldFN0b3J5Q29udGVudCBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBsb2FkIHRoZSBjbGlja2VkXG4vLyBzdG9yeSBpbnRvIHRoZSBzZWxlY3RlZCBkaXZcbmZ1bmN0aW9uIGdldFN0b3J5Q29udGVudCAoJGh0dHApIHtcbiAgXG4gIC8vIHRoZSBiYXNlIHVybCB0byByZXF1ZXN0IHRoZSBzdG9yeWRhdGEgZnJvbVxuICB2YXIgdXJsID0gJ2h0dHA6Ly9nb2xmd2Vlay5jb20vJztcblxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gKGN0eCkgeyAgICAgIFxuICAgICAgJGh0dHAucG9zdCh1cmwgKyBjdHguc2x1ZyArICc/anNvbicpXG4gICAgICAgIC5zdWNjZXNzKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgY3R4LnN0b3J5U3VjY2VzcyhkYXRhKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmVycm9yKGZ1bmN0aW9uIChkYXRhLCBzdGF0dXMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhLCBzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBBc3NpZ24gZ2V0U3RvcnlMaXN0IGFzIGFuIGFuZ3VsYXIgZmFjdG9yeSBcbi8vIGluIGEgbWFubmVyIHNhZmUgZm9yIG1pbmlmaWNhdGlvblxuaW5mc2NyLmZhY3RvcnkoJ2dldFN0b3J5Q29udGVudCcsIFsnJGh0dHAnLCBnZXRTdG9yeUNvbnRlbnRdKTtcblxuXG5cbi8vIHRoZSBpbmZTY3JvbGxDb250cm9sbGVyIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgXG4vLyBpbiB0aGUgZGl2IHdoZXJlIHRoZSBzdG9yaWVzIHNob3VsZCBiZSBhZGRlZCBmb3IgaW5maW5pdGUgXG4vLyBzY3JvbGxpbmdcbmZ1bmN0aW9uIGluZlNjcm9sbENvbnRyb2xsZXIgKCRzY29wZSwgJHdpbmRvdywgc3RvcnlMaXN0LCBzdG9yeSkge1xuXHQkc2NvcGUuY291bnQgPSAxNTsgIC8vIG51bWJlciBvZiBzdG9yaWVzIHRvIGdldFxuXHQkc2NvcGUuZmV0Y2hpbmcgPSBmYWxzZTsgLy8gYXJlIHdlIGZldGNoaW5nIHJpZ2h0IG5vdz9cbiAgJHNjb3BlLnN0b3JpZXMgPSBbXTsgLy8gc3RhcnRzIG91dCBhcyBhbiBlbXB0eSBhcnJheVxuXG4gICRzY29wZS4kb24oJ0xPQUQnLCBmdW5jdGlvbiAoZSkgeyAkc2NvcGUuZmV0Y2hpbmcgPSB0cnVlOyB9KTtcbiAgJHNjb3BlLiRvbignTE9BRERPTkUnLCBmdW5jdGlvbiAoZSkgeyAkc2NvcGUuZmV0Y2hpbmcgPSBmYWxzZTsgfSk7XG5cbiAgLy8gdGhpcyBpcyB0aGUgc3VjY2VzcyBoYW5kbGVyIHdoZW4gZGF0YSBpcyByZWNlaXZlZFxuICAkc2NvcGUuc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgYW5ndWxhci5mb3JFYWNoKGRhdGEuc3RvcmllcywgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICB0aGlzW2tleV0gPSB2YWw7XG4gICAgfSwgJHNjb3BlLnN0b3JpZXMpO1xuICAgIC8vIGNvbnNvbGUubG9nKCclTycsICRzY29wZS5zdG9yaWVzWzBdKTtcbiAgICAvLyBsZXQgZXZlcnl0aGluZyBrbm93IHdlIGFyZSBkb25lIGxvYWRpbmdcbiAgICAkc2NvcGUuJGVtaXQoJ0xPQURET05FJyk7XG4gIH1cblxuICAvLyBnZXQgdGhlIHN0b3JpZXMgdGhlIGZpcnN0IHRpbWVcbiAgc3RvcnlMaXN0LmdldCgkc2NvcGUpO1xuXG4gIC8vIGdldE1vcmUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgZGl2IGlzIHNjcm9sbGVkXG5cdCRzY29wZS5nZXRNb3JlID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vIGlmIHBhZ2UgcG9zaXRpb24gaXMgYmlnZ2VyIHRoYW4gODggXG5cdFx0Ly8gZmV0Y2ggbW9yZSBzdG9yaWVzXG5cdFx0aWYgKCEkc2NvcGUuZmV0Y2hpbmcpIHtcbiAgICAgICRzY29wZS4kZW1pdCgnTE9BRCcpO1xuICAgICAgJHNjb3BlLmNvdW50ID0gKCRzY29wZS5jb3VudCA9PT0gNjApID8gNjAgOiAkc2NvcGUuY291bnQgKyAxNTtcblx0XHRcdC8vIGxldCBldmVyeXRoaW5nIGtub3cgd2UgYXJlIGxvYWRpbmdcbiAgICAgIHN0b3J5TGlzdC5nZXQoJHNjb3BlKTtcblxuXHRcdH1cblx0fVxuXG4gICRzY29wZS5zdG9yeVN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIHNldCB0aGUgZGF0YSBoZXJlIHRvIHRoZSBleHBhbmRpbmcgZGl2IGZvciB0aGUgc3RvcnlcbiAgICAvLyBjb25zb2xlLmxvZygnJW8nLCAkc2NvcGUuc3Rvcmllcyk7XG4gICAgJHNjb3BlLnN0b3JpZXNbJHNjb3BlLnN0b3J5SWRdWydzdG9yeUNvbnRlbnQnXSA9IGRhdGEuc3RvcnlbMF07XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4gIH1cblxuXG4gICRzY29wZS5zdG9yeUNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCclbycsdGhpcy4kaW5kZXgpXG4gICAgJHNjb3BlLnNsdWcgPSB0aGlzLnN0b3J5LmlkO1xuICAgICRzY29wZS5zdG9yeUlkID0gdGhpcy4kaW5kZXg7XG4gICAgc3RvcnkuZ2V0KCRzY29wZSk7XG4gIH1cblxuXG59XG5cblxuLy8gQXNzaWduIGluZlNjcm9sbENvbnRyb2xsZXIgYXMgYW4gYW5ndWxhciBjb250cm9sbGVyIFxuLy8gaW4gYSBtYW5uZXIgc2FmZSBmb3IgbWluaWZpY2F0aW9uXG5pbmZzY3IuY29udHJvbGxlcignaW5mU2Nyb2xsQ3RybCcsIFsnJHNjb3BlJywgJyR3aW5kb3cnLCAnZ2V0U3RvcnlMaXN0JywgJ2dldFN0b3J5Q29udGVudCcsIGluZlNjcm9sbENvbnRyb2xsZXJdKTtcblxuXG5cblxuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIFRIRUNPREUgPSBbMzgsMzgsNDAsNDAsMzcsMzksMzcsMzksNjYsNjVdO1xuXG4gIHZhciB0ZXN0Y29kZSA9IFtdO1xuICB2YXIgdGltZTtcblxuICAvLyBrIGNvZGUgc3R1ZmZcbiAgZnVuY3Rpb24gY2hlY2tLZXlzIChlKSB7XG4gICAgdmFyIGJ1dHRvbiA9IChlLmtleUNvZGUpO1xuXG4gICAgaWYgKFRIRUNPREUuaW5kZXhPZihidXR0b24pID4gLTEpIHtcbiAgICAgIHRlc3Rjb2RlW3Rlc3Rjb2RlLmxlbmd0aF0gPSBlLmtleUNvZGU7XG5cbiAgICAgIGlmICh0ZXN0Y29kZS5sZW5ndGggPT09IFRIRUNPREUubGVuZ3RoKSB7XG4gICAgICAgIGNoZWNrQ29kZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJDb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDb2RlICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRIRUNPREUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChUSEVDT0RFW2ldICE9PSB0ZXN0Y29kZVtpXSkge1xuICAgICAgICB0ZXN0Y29kZSA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlc3Rjb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdkdWYgdGltZSEnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckNvZGUgKCkge1xuICAgIGlmICh0aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWUgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGVzdGNvZGUgPSBbXTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lKTtcbiAgICAgIH0sIDEwMDAwKTtcbiAgICB9XG4gIH1cblxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXlzKTtcbn0pKClcblxufSkoYW5ndWxhcik7Il19
